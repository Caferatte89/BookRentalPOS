package my.edu.tarc.dco.bookrentalpos;

import bookrentalpos._stockLevelReportTableData;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

/**
 * Class used to load all the Book data from the database
 *
 * @author Looz
 * @version 1.0
 */
public class BookManager extends Manager<Book> {

    private Book[] bookList;
    private int bookCount;
    private DBManager db;
    private final int ARRAY_SIZE = 100;

    public BookManager(DBManager db) {
        bookList = new Book[ARRAY_SIZE];
        this.db = db;
        reload();
    }

    /**
     * Reload all the data from database
     */
    @Override
    public void reload() {
        bookCount = 0;
        String sql = "SELECT * FROM book;";
        try {
            java.sql.ResultSet rs = db.resultQuery(sql);
            while (rs.next()) {
                Book s = new Book(
                        rs.getInt("id"),
                        rs.getString("date"),
                        rs.getString("title"),
                        rs.getString("author"),
                        rs.getDouble("retailPrice"),
                        rs.getInt("lastRentedBy"),
                        rs.getInt("lastReservedBy"),
                        rs.getInt("isRented") == 0 ? false : true,
                        rs.getInt("isReserved") == 0 ? false : true
                );
                bookList[bookCount++] = s;
            }
        } catch (java.sql.SQLException err) {
            System.out.println(err.getMessage());
        }
    }

    /**
     * Get the reference to the book object with specified ID
     *
     * @return Reference to the book object in this class. Will return null if
     * book of specified ID was not found
     */
    @Override
    public Book getById(int bookID) {
        for (int i = 0; i < bookCount; i++) {
            if (bookList[i].getId() == bookID) {
                return bookList[i];
            }
        }
        return null;
    }

    /**
     * Get the reference to the book object with specified Name
     *
     * @return Reference to the book object in this class. Will return null if
     * book of specified Name was not found
     */
    @Override
    public Book getByName(String name) {
        for (int i = 0; i < bookCount; i++) {
            if (bookList[i].getName().equals(name)) {
                return bookList[i];
            }
        }
        return null;
    }

    /**
     * Get a copy of the booklist array<br>
     * For now, you should use BookManager.getBookCount() to get the array size
     *
     * @return Book array with constant size of ARRAY_SIZE
     * @see BookManager#getBookCount()
     * @see BookManager#ARRAY_SIZE
     */
    @Override
    public Book[] getCache() {
        return this.bookList.clone();
    }

    /**
     * Add new book entry to the database
     *
     * @param book Book object (without ID)
     * @return True if the book is added to database successfully
     * @see Book#Book(String, String, double)
     */
    @Override
    public boolean add(Book book) {
        String sql = String.format("INSERT INTO book(title, retailPrice, author, lastRentedBy, lastReservedBy, isRented, isReserved) VALUES('%s', '%f', '%s', %s, %s, %d, %d)",
                book.getName(),
                book.getRetailPrice(),
                book.getAuthor(),
                book.getLastRentedBy() == 0 ? "null" : book.getLastRentedBy() + "",
                book.getLastReservedBy() == 0 ? "null" : book.getLastReservedBy() + "",
                book.isRented() ? 1 : 0,
                book.isReserved() ? 1 : 0
        );
        if (db.updateQuery(sql) == 1) {
            try {
                // id and date is generated by sqlite, i need to make a copy of it and store it in my preloaded database
                // this query basically get the latest Mmeber entry inserted into database
                ResultSet rs = db.resultQuery("SELECT id, date FROM book WHERE id = (SELECT seq FROM sqlite_sequence WHERE name='book')");
                book.setID(rs.getInt("id"));
                book.setDateCreated(rs.getString("date"));

                // store in my preloaded database
                bookList[bookCount++] = book;
            } catch (SQLException err) {
                System.out.println(err.getMessage());
            }
            return true;
        } else {
            return false;
        }
    }

    /**
     * Update the book entry into database
     *
     * @param bk Book Object to be updated (must contain ID)
     * @return True if the book is successfuly updated. Will return false if it
     * failed or the provided Book object dont contain ID
     */
    @Override
    public boolean update(Book bk) {
        if (bk.getId() == 0) {
            return false;
        }
        String sql = String.format("UPDATE book\n"
                        + "SET title='%s', author='%s', retailPrice=%f, lastRentedBy=%s, lastReservedBy=%s, isRented=%d, isReserved=%d\n"
                        + "WHERE id=%d;",
                bk.getName(),
                bk.getAuthor(),
                bk.getRetailPrice(),
                bk.getLastRentedBy() == 0 ? "null" : bk.getLastRentedBy() + "",
                bk.getLastReservedBy() == 0 ? "null" : bk.getLastReservedBy() + "",
                bk.isRented() ? 1 : 0,
                bk.isReserved() ? 1 : 0,
                bk.getId());
        if (db.updateQuery(sql) == 1) {
            return true;
        }
        return false;
    }

    /**
     * Remove the book from the database<br>
     * NOTE: All the related table will have this book removed as well
     *
     * @param bookID BookID to be removed
     * @return True if the book is removed successfully
     */
    @Override
    public boolean remove(int bookID) {
        db.execQuery("UPDATE transactions\n"
                + "SET bookInvolved=NULL\n"
                + "WHERE bookInvolved=" + bookID);
        String sql = String.format("DELETE FROM book WHERE id=%d", bookID);
        Book[] tmpList = new Book[ARRAY_SIZE];
        if (db.updateQuery(sql) == 1) {
            int b = 0;
            for (int a = 0; a < bookCount; a++) {
                if (bookList[a].getId() != bookID) {
                    tmpList[b++] = bookList[a];
                }
            }
            bookList = tmpList.clone();
            bookCount--;
            return true;
        } else {
            return false;
        }
    }

    /**
     * This function returns an arraylist of stockLevelReportTableData<br>
     * The idea of this method: I abused the fact that COUNT() only returns the count of not null values.<br>
     * So, to actually count the number of rented books, all i have to do is temporary set those not rented
     * books(marked as 0) to null and then execute the query<br>
     * After the function ends, the query will update null values back to 0<br>
     *
     * @return Arraylist of type _stockLevelReportTableData
     */
    public ArrayList<_stockLevelReportTableData> getBookCountInSystem() {
        // Set books that are not rented as null
        db.execQuery("UPDATE book SET isRented = null WHERE isRented == 0;");

        // Bad naming, yes, im sorry
        ArrayList<_stockLevelReportTableData> rlrtd = new ArrayList<_stockLevelReportTableData>();
        // How I abused COUNT()
        String sql = "SELECT DISTINCT title, author, COUNT(isRented) as booksRented, COUNT(title) AS bookCount, retailPrice * COUNT(title) AS amountInMYR FROM book GROUP BY title, author;";
        ResultSet rs;
        if ((rs = db.resultQuery(sql)) == null) {
            // Set books that are not rented back to 0
            db.execQuery("UPDATE book SET isRented = 0 WHERE isRented is null; ");
            return null;
        }
        try {
            while (rs.next()) {
                rlrtd.add(
                        new _stockLevelReportTableData(rs.getString("title"),
                                rs.getString("author"),
                                rs.getInt("bookCount") + "",
                                (rs.getInt("bookCount") - rs.getInt("booksRented")) + "",
                                String.format("%.2f", rs.getDouble("amountInMYR"))
                        ));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        // Set books that are not rented back to 0
        db.execQuery("UPDATE book SET isRented = 0 WHERE isRented is null; ");
        return rlrtd;
    }

    /**
     * This function returns an array list of reference to the books record where it is currently rented by specifed member
     * @param memID member ID
     * @return arraylist of type Book
     */
    public ArrayList<Book> getBooksRentedByMember(int memID) {
        ArrayList<Book> b = new ArrayList<Book>();
        for (int a = 0; a < this.bookCount; a++) {
            if (bookList[a].isRented() && bookList[a].getLastRentedBy() == memID) {
                b.add(bookList[a]);
            }
        }
        return b;
    }

    /**
     * @return Book count loaded into this instance from database
     */
    public int getBookCount() {
        return this.bookCount;
    }

}
